from numpy import *

from time import time;

# Iterative:  0
# 16.7712788582s
# Iterative:  1
# 21.8291988373s
# Iterative:  2
# 27.0093688965s
# Iterative:  3
# 32.1887328625s
# Iterative:  4
# 37.7486479282s




# walls = {(3, 1), (0, 3)}
# terminals = {(4, 2): 10, (2,4):5}
# cols = 6
# rows = 5
# gamma = 0.7
# p = 0.8
# p_ = 0.1
# p2 = 0.6
# p2_ = 0.2



# 500,600
# 0
# 1
# 100,100,10.00
# 1,1
# 0,0
# 0.7


# walls = {}
# terminals = {(100, 100): 10}
# rows = 500
#
# cols = 600
# gamma = 0.7
# p = 1
# p_ = 0
# p2 = 1
# p2_ = 0


# def best_policy(mdp1, mdp2, U):
#     """Given an MDP and a utility function U, determine the best policy,
#     as a mapping from state to action. (Equation 17.4)"""
#     pi = {}
#     for s in mdp1.states:
#         pi[s] = max(mdp1.actions(s) + mdp2.actions(s), key=lambda a: expected_utility(a, s, U, mdp1, mdp2))
#
#     return pi
#
# def expected_utility(a, s, U, mdp1, mdp2, gamma):
#     """The expected utility of doing a in state s, according to the MDP and U."""
#     if a in mdp1.actions(s):
#         res = mdp1.R(s) + gamma * sum(p * U[s1] for (p, s1) in mdp1.T(s, a));
#     elif a in mdp2.actions(s):
#         res = mdp2.R(s) + gamma * sum(p * U[s1] for (p, s1) in mdp2.T(s, a));
#     return res;

def best_policy(a, b, gamma, r1, r2, U, rows, cols):
    pi = {}
    actlist_1 = [(0, -1), (1, 0), (0, 1), (-1, 0)]
    actlist_2 = [(0, -2), (2, 0), (0, 2), (-2, 0)]
    iter_order = [[3,2,0],[2,3,1], [1,2,0], [0,1,3]]
    for i in range(rows):
        for j in range(cols):
            if (i, j) in walls:
                pi[(i, j)] = None
            elif (i, j) in terminals:
                pi[(i, j)] = (0, 0)
            else:
                max_state = -10000000
                res = (0, 0)
                for k in range(4):
                    trans = b[i][j]
                    iter = iter_order[k]
                    x1, y1 = trans[iter[1]]
                    x2, y2 = trans[iter[0]]
                    x3, y3 = trans[iter[2]]
                    # print x1, y1, x2, y2, x3, y3
                    sum_dir = r2[i][j] + gamma * ((U[x1][y1] + U[x3][y3]) * p2_ + U[x2][y2] * p2)
                    if max_state < sum_dir:
                        max_state = sum_dir
                        res = actlist_2[k]
                for k in range(4):
                    trans = a[i][j]
                    iter = iter_order[k]

                    x1, y1 = trans[iter[1]]
                    x2, y2 = trans[iter[0]]
                    x3, y3 = trans[iter[2]]
                    # print x1, y1, x2, y2, x3, y3
                    sum_dir = r1[i][j] + gamma * ((U[x1][y1] + U[x3][y3]) * p_ + U[x2][y2] * p)
                    if max_state < sum_dir:
                        max_state = sum_dir
                        res = actlist_1[k]
                pi[(i,j)] = res



    return pi
# def best_policy(a, b, gamma, r1, r2, U, rows, cols):
#     pi = {}
#     actlist_1 = [(-1, 0), (1, 0), (0, -1), (0, 1)]
#     actlist_2 = [(-2, 0), (2, 0), (0, -2), (0, 2)]
#     order = [[1, 2, 0], [3,1,2], [0,3,1], [2,0,3]]
#     for i in range(rows):
#         for j in range(cols):
#
#             if (i, j) not in walls and (i, j) not in terminals:
#                 max_state = -10000000
#                 res = (0, 0)
#                 for k in range(4):
#                     #the first order[2,3,1], first left(down, up)
#                     list = order[k]
#                     x1, y1 = actlist_2[list[1]]
#                     x2, y2 = actlist_2[list[0]]
#                     x3, y3 = actlist_2[list[2]]
#                     # print x1, y1, x2, y2, x3, y3
#                     sum_dir = r2[i][j] + gamma * ((U[x1 + i][y1 + j] + U[x3 + i][y3 + j]) * p_ + U[x2 + i][y2 + j] * p)
#                     if max_state < sum_dir:
#                         max_state = sum_dir
#                         res = actlist_2[(k + 1) % 4]
#                 for k in range(4):
#                     #the first order[2,3,1], first left(down, up)
#                     list = order[k]
#                     x1, y1 = actlist_1[list[1]]
#                     x2, y2 = actlist_1[list[0]]
#                     x3, y3 = actlist_1[list[2]]
#                     # print x1, y1, x2, y2, x3, y3
#                     sum_dir = r1[i][j] + gamma * ((U[x1 + i][y1 + j] + U[x3 + i][y3 + j]) * p_ + U[x2 + i][y2 + j] * p)
#                     if max_state < sum_dir:
#                         max_state = sum_dir
#                         res = actlist_1[(k + 1) % 4]
#
#
#                 # for k in range(4):
#                 #     list = b[i][j]
#                 #     x1, y1 = list[k]
#                 #     x2, y2 = list[(k + 1) % 4]
#                 #     x3, y3 = list[(k + 2) % 4]
#                 #     # print x1, y1, x2, y2, x3, y3
#                 #     sum_dir = r2[i][j] + gamma * ((U[x1][y1] + U[x3][y3]) * p2_ + U[x2][y2] * p2)
#                 #     if max_state < sum_dir:
#                 #         max_state = sum_dir
#                 #         res = actlist_2[(k + 1) % 4]
#                 pi[(i,j)] = res
#             elif (i, j) in walls:
#                 pi[(i, j)] = None
#             else:
#                 pi[(i, j)] = (0, 0)
#
#
#     return pi

def read_and_process_input(filename):
    # import the file
    fo = open(filename)
    input = [line.strip("\n") for line in fo.readlines()]
    fo.close()

    # line 1: the rows number and cols number of grid
    size = input[0].split(',')
    rows, cols = int(size[0]), int(size[1])

    # line 2: wall number
    wall_number = int(input[1])

    # walls
    walls = set()
    for i in range(0, wall_number):
        w = input[2 + i].split(',')
        walls.add((int(w[0]) - 1, int(w[1]) - 1))
    # terminals number
    terminals_number = int(input[2 + wall_number])

    # terminals
    terminals_line = 2 + wall_number + 1
    terminals = {};
    for i in range(0, terminals_number):
        t = input[terminals_line + i].split(',')
        terminals[(int(t[0]) - 1, int(t[1]) - 1)] = float(t[2])

    # probability: p_run and p_walk
    p_line = terminals_line + terminals_number
    p = input[p_line].split(',')
    p_walk, p_run = float(p[0]), float(p[1])

    # rewards
    r = input[p_line + 1].split(',')

    gamma = float(input[p_line + 2])

    return walls, terminals, rows, cols, gamma, p_walk, p_run


# walls = {}
# terminals = {(100, 100): 10}
# rows = 500
#
# cols = 600
# gamma = 0.7
# p = 1
# p_ = 0
# p2 = 1
# p2_ = 0

def test(answer, my_answer):
    row = len(answer)
    col = len(answer[0])
    if row != len(my_answer) or col != len(my_answer[0]):
        print "Size not equal"
        return

    # for i in range(0, row):
    #     print answer[i]
    # print "begin to print my_answer: "
    # for i in range(0, row):
    #     print my_answer[i]

    fail = False
    for i in range(0, row):
        for j in range(0, col):
            flag = answer[i][j] == my_answer[i][j],
            print flag,
            if not flag[0]:
                fail = True
        print
    if fail:
        print "Fail"
    else:
        print "All pass"

def write_file(table):
    rows = len(table)
    cols = len(table[0])
    fo = open("output.txt", 'w')
    for i in range(0, rows):
        for j in range(0, cols - 1):
            fo.write(table[i][j])
            fo.write(',')
        fo.write(table[i][cols - 1])
        fo.write("\n")
    fo.close()


def res_reverse(tmp):
    rows = len(tmp)
    cols = len(tmp[0])
    my_answer = [['None' for i in range(cols)] for j in range(rows)]

    # my_answer = zeros(rows * cols, str).reshape(rows, cols)
    for i in range(0, rows):
        for j in range(0, cols):
            if tmp[rows - 1 - i][j] == 0:
                my_answer[i][j] = 'None'
            elif tmp[rows - 1 - i][j] == 'Run Up':
                my_answer[i][j] = 'Run Down'
            elif tmp[rows - 1 - i][j] == 'Run Down':
                my_answer[i][j] = 'Run Up'
            elif tmp[rows - 1 - i][j] == 'Walk Down':
                my_answer[i][j] = 'Walk Up'
            elif tmp[rows - 1 - i][j] == 'Walk Up':
                my_answer[i][j] = 'Walk Down'
            else:
                my_answer[i][j] = tmp[rows - 1 - i][j]
    return my_answer
def test_2(my_output, output):
    my_output = read_output(my_output);
    output = read_output(output)
    test(output, my_output)

def transitions(step, rows, cols, walls):
    a = [[[] for i in range(cols)] for j in range(rows)]

    for i in range(rows):
        for j in range(cols):
            # up   left    down   right
            a[i][j] = [[-step + i, 0 + j], [0 + i, step + j], [step + i, 0 + j], [0 + i, -step + j]]


            if i <= step - 1 or (i - step, j) in walls or (i - step + 1, j) in walls:
                a[i][j][0][0] = a[i][j][0][0] + step
            if j >= cols - step or (i, j + step) in walls or (i, j + step - 1) in walls:
                a[i][j][1][1] = a[i][j][1][1] - step


            if i >= rows - step or (i + step, j) in walls or (i + step - 1, j) in walls:
                a[i][j][2][0] = a[i][j][2][0] - step

            if j <= step - 1 or (i, j - step) in walls or (i, j - step + 1) in walls:
                a[i][j][3][1] = a[i][j][3][1] + step

    return a




def read_output(filename):
    fo = open(filename)
    output = [line.strip("\n") for line in fo.readlines()]
    fo.close()
    output1 = []
    for line in output:
        output1.append(line.split(','))
    return output1



def iteration(U, gamma, p, p_, p2, p2_):
    U1 = U.copy()
    delta = 0
    for i in range(rows):
        for j in range(cols):

            if (i, j) not in walls or (i, j) not in terminals:
                max_state = -10000000

                for k in range(4):
                    list = a[i][j]
                    x1, y1 = list[k]
                    x2, y2 = list[(k + 1) % 4]
                    x3, y3 = list[(k + 2) % 4]
                    # print x1, y1, x2, y2, x3, y3
                    sum_dir = r1[i][j] + gamma * ((U[x1][y1] + U[x3][y3]) * p_ + U[x2][y2] * p)
                    max_state = max(sum_dir, max_state)
                for k in range(4):
                    list = b[i][j]
                    x1, y1 = list[k]
                    x2, y2 = list[(k + 1) % 4]
                    x3, y3 = list[(k + 2) % 4]
                    # print x1, y1, x2, y2, x3, y3
                    sum_dir = r2[i][j] + gamma * ((U[x1][y1] + U[x3][y3]) * p2_ + U[x2][y2] * p2)
                    max_state = max(sum_dir, max_state)



                U1[i][j] = max_state
                if (i, j) in terminals:
                    # U1[2][4] = 5
                    # U1[4][2] = 10
                    for ele in terminals:
                        (x, y) = ele
                        U1[x][y] = terminals[ele]
                delta = max(delta, abs(U1[i][j] - U[i][j]))
        # print U1,
    return U1, delta


def iteration_main(epsilon = 0.00000001):
    U = zeros(rows * cols).reshape(rows, cols)
    print("Start to iteration" + str(time() - start) + "s")
    count = 0
    while True:
    # for i in range(22):
        print("Start to iteration:" + str(count))
        print("cost"+ str(time() - start) + "s")
        count = count + 1

        U, delta = iteration(U, gamma, p, p_, p2, p2_)
        print U
        if delta < epsilon * (1 - gamma) / gamma:
            break;
    return U



def to_grid(mapping):
    rows = 5
    cols = 6
    """Convert a mapping from (x, y) to v into a [[..., v, ...]] grid."""
    # list = zeros(self.rows * self.cols, str).reshape(self.rows, self.cols)
    list = [[0 for i in range(cols)] for j in range(rows)]

    for k in mapping.keys():
        i = k[0]
        j = k[1]
        list[i][j] = mapping[k]
    return list


def to_words(policy, rows, cols):
    chars = {(0, 1): 'Walk Right', (-1, 0): 'Walk Up', (0, -1): 'Walk Left', (1, 0): 'Walk Down', (0, 2): 'Run Right',
             (-2, 0): 'Run Up', (0, -2): 'Run Left', (2, 0): 'Run Down', None: 'None', (0, 0):'Exit'}
    # return to_grid({s: chars[a] for (s, a) in policy.items()})
    # return to_grid({s: chars[a] for (s, a) in policy.items()})
    list = [[0 for i in range(cols)] for j in range(rows)]
    for k in policy.keys():
        i = k[0]
        j = k[1]
        # print policy[k]
        list[i][j] = chars[policy[k]]
    return list





def res_reverse(tmp):
    rows = len(tmp)
    cols = len(tmp[0])
    my_answer = [['None' for i in range(cols)] for j in range(rows)]

    # my_answer = zeros(rows * cols, str).reshape(rows, cols)
    for i in range(0, rows):
        for j in range(0, cols):
            if tmp[rows - 1 - i][j] == 0:
                my_answer[i][j] = 'None'
            elif tmp[rows - 1 - i][j] == 'Run Up':
                my_answer[i][j] = 'Run Down'
            elif tmp[rows - 1 - i][j] == 'Run Down':
                my_answer[i][j] = 'Run Up'
            elif tmp[rows - 1 - i][j] == 'Walk Down':
                my_answer[i][j] = 'Walk Up'
            elif tmp[rows - 1 - i][j] == 'Walk Up':
                my_answer[i][j] = 'Walk Down'
            else:
                my_answer[i][j] = tmp[rows - 1 - i][j]
    return my_answer




def preprocessing_BFS(U, queue, mdp1, mdp2, visited):

    U1 = U.copy()
    rows = len(mdp1.grid)
    cols = len(mdp1.grid[0])
    delta = 0;
    count = 0

    while not queue.empty():
        node = queue.get()
        coun = count + 1

        # print node
        new_delta = equation(U, U1, mdp1, mdp2, node, mdp1.gamma)
        # print node, U1[node]
        delta = max(delta, new_delta)

        for dir in orientations:
            new_node = (node[0] + dir[0], node[1] + dir[1])
            if valid(new_node, rows, cols, mdp1) and new_node not in visited:
                queue.put(new_node)
                visited.add(new_node)

    return U1, delta
import Queue

def BFS_iteration(input_walk, input_run, terminals, gamma):
    values = {s: 0 for s in input_walk.states}  # initial utility
    # print("Start to iteration" + str(time() - start) + "s")

    # values = zeros(input_walk.rows * input_walk.cols).reshape(input_walk.rows, input_walk.cols)

    epsilon = .000001
    count = 0

    for i in range(0):
        print "IterativeBFS: ", count
        print("time: " + str(time() - start) + "s")
        visited = set()
        queue = Queue.Queue()

        for seed in terminals:
            queue.put(seed)
            visited.add(seed)
            values[seed] = terminals[seed]
        values, delta = preprocessing_BFS(values, queue, input_run, input_walk, visited)
        if delta < epsilon * (1 - gamma) / gamma:
            break;
    return values











start = time()


walls, terminals, rows, cols, gamma, p_walk, p_run = read_and_process_input("input2.txt")
p = p_walk
p_ = (1 - p_walk) / 2
p2 = p_run
p2_ = (1 - p_run) / 2

a = transitions(1, rows, cols, walls)
b = transitions(2, rows, cols, walls)

reward_1 = - 0.3
reward_2 = - 0.2
r1 = zeros(rows * cols).reshape(rows, cols) + reward_1
r2 = zeros(rows * cols).reshape(rows, cols) + reward_2

for ele in terminals:
    (x, y) = ele
    r1[x][y] = r2[x][y] = terminals[ele]

values =  iteration_main()
print("start to best_policy: " + str(time() - start) + "s")

pi = best_policy(a, b, gamma, r1, r2, values, rows, cols)

tmp = to_words(pi, rows, cols)

my_answer = res_reverse(tmp)
print my_answer
# write my_answer to the file
write_file(my_answer)
print("end: " + str(time() - start) + "s")

test_2("output.txt", "output2.txt")

# {(0, 1): 1.4108412363084892, (3, 2): 5.976333073083332, (1, 3): 1.8320904085812393, (3, 0): 3.01093608614544, (0, 4): 2.638888888863982, (2, 1): 2.894775900017857, (0, 0): 1.7087624926586638, (0, 5): 1.3817623827858532, (1, 4): 2.7355075606939634, (4, 2): 10.0, (2, 5): 2.738494010430594, (1, 0): 1.7153942811835494, (4, 0): 5.159651965220217, (1, 2): 2.93318610200854, (0, 2): 2.5545266626064578, (3, 3): 3.68556797122655, (2, 0): 3.123576584647687, (3, 4): 3.149687646307079, (4, 4): 5.465116279069767, (2, 4): 5.0, (1, 5): 1.5323034115384464, (4, 3): 5.976333073083332, (2, 2): 5.137300700995563, (4, 5): 3.131917502077431, (2, 3): 3.0987176583275406, (3, 5): 1.874753887492209, (4, 1): 6.162790697674419, (1, 1): 1.6464750222775058}


# [1.70876265 1.41084142 2.55452678 1.49242592 2.63888889 1.38176238]
# [1.71539441 1.64647513 2.93318615 1.83209045 2.73550757 1.53230341]
# [3.12357665 2.89477596 5.13730072 3.09871768 5.         2.73849401]
# [3.01093615 1.83540121 5.97633307 3.68556797 3.14968765 1.87475389]
# [ 5.159652    6.1627907  10.          5.97633307  5.46511628  3.1319175 ]



# from time import time;
# start = time()
# print "test"
# b = arange(1000 * 1000).reshape(1000, 1000)
# print b
# a = arange(1000 * 1000, list).reshape(1000, 1000)
#
# print a
# print(str(time() - start))
# # a[0][0] = [(1, 0), (0, 1)]
# # print a[0][0]
#
# (0, 0) (4518896272) = {float} -0.34
# (0, 1) (4518896560) = {float} -0.34
# (0, 2) (4518896704) = {float} -0.34
# (0, 4) (4518896848) = {float} 1.844
# (0, 5) (4518896992) = {float} -0.34
# (1, 0) (4518897136) = {float} -0.34
# (1, 1) (4518897280) = {float} -0.34
# (1, 2) (4518897424) = {float} -0.34
# (1, 3) (4518897568) = {float} -0.34
# (1, 4) (4518897712) = {float} 2.472
# (1, 5) (4518897856) = {float} -0.34
# (2, 0) (4518898000) = {float} -0.34
# (2, 1) (4518898144) = {float} -0.34
# (2, 2) (4518898288) = {float} 4.672
# (2, 3) (4518898432) = {float} 2.472
# (2, 4) (4518898576) = {float} 5.0
# (2, 5) (4518898720) = {float} 2.472
# (3, 0) (4518898864) = {float} -0.34
# (3, 2) (4518899008) = {float} 5.272
# (3, 3) (4518899152) = {float} -0.34
# (3, 4) (4518899296) = {float} 2.472
# (3, 5) (4518899440) = {float} -0.34
# (4, 0) (4518899584) = {float} 3.944
# (4, 1) (4518899792) = {float} 5.272
# (4, 2) (4518899936) = {float} 10.0
# (4, 3) (4518900080) = {float} 5.272
# (4, 4) (4518900224) = {float} 4.672
# (4, 5) (4518900368) = {float} -0.34


#
# 0.00325798988342s
# {(1, 3): -0.2, (3, 0): -0.2, (2, 1): -0.2, (2, 5): -0.2, (4, 0): -0.2, (1, 2): -0.2, (3, 3): -0.2, (4, 4): -0.2, (1, 5): -0.2, (2, 2): -0.2, (4, 1): -0.2, (1, 1): -0.2, (3, 2): -0.2, (0, 0): -0.2, (4, 5): -0.2, (0, 4): -0.2, (1, 4): -0.2, (0, 5): -0.2, (4, 2): 10.0, (1, 0): -0.2, (3, 5): -0.2, (0, 1): -0.2, (2, 4): 5.0, (2, 0): -0.2, (4, 3): -0.2, (2, 3): -0.2, (3, 4): -0.2, (0, 2): -0.2}
# Iterative:  2
# 0.00412201881409s
# {(1, 3): -0.33999999999999997, (3, 0): -0.33999999999999997, (2, 1): -0.33999999999999997, (2, 5): 2.472, (4, 0): 3.944, (1, 2): -0.33999999999999997, (3, 3): -0.33999999999999997, (4, 4): 4.672, (1, 5): -0.33999999999999997, (2, 2): 4.672, (4, 1): 5.272, (1, 1): -0.33999999999999997, (3, 2): 5.272, (0, 0): -0.33999999999999997, (4, 5): -0.33999999999999997, (0, 4): 1.844, (1, 4): 2.472, (0, 5): -0.33999999999999997, (4, 2): 10.0, (1, 0): -0.33999999999999997, (3, 5): -0.33999999999999997, (0, 1): -0.33999999999999997, (2, 4): 5.0, (2, 0): -0.33999999999999997, (4, 3): 5.272, (2, 3): 2.472, (3, 4): 2.472, (0, 2): -0.33999999999999997}
# Iterative:  3
# 0.00500297546387s
# {(1, 3): 1.23356, (3, 0): 1.8610400000000002, (2, 1): 2.2687200000000005, (2, 5): 2.4524000000000004, (4, 0): 4.50456, (1, 2): 2.31272, (3, 3): 3.1944, (4, 4): 5.35408, (1, 5): 1.23356, (2, 2): 4.6524, (4, 1): 6.038080000000001, (1, 1): -0.43799999999999994, (3, 2): 5.645239999999999, (0, 0): -0.43799999999999994, (4, 5): 2.31272, (0, 4): 2.41632, (1, 4): 2.4524000000000004, (0, 5): 0.7430399999999997, (4, 2): 10.0, (1, 0): -0.43799999999999994, (3, 5): 1.23356, (0, 1): -0.43799999999999994, (2, 4): 5.0, (2, 0): 2.2667999999999995, (4, 3): 5.645239999999999, (2, 3): 2.4524000000000004, (3, 4): 2.7064, (0, 2): 1.6670399999999999}
# Iterative:  4
# 0.00585699081421s
# {(1, 3): 1.4069023999999999, (3, 0): 2.4830991999999994, (2, 1): 2.4334944000000003, (2, 5): 2.6726984000000003, (4, 0): 4.947990399999999, (1, 2): 2.4530167999999994, (3, 3): 3.4459491999999994, (4, 4): 5.4495712, (1, 5): 1.3313612000000001, (2, 2): 5.017352, (4, 1): 6.145331200000001, (1, 1): 1.1232736, (3, 2): 5.9187748000000004, (0, 0): 0.9241215999999999, (4, 5): 2.9465244, (0, 4): 2.5765696, (1, 4): 2.6726984000000003, (0, 5): 1.1915011999999996, (4, 2): 10.0, (1, 0): 0.9705680000000001, (3, 5): 1.5491423999999998, (0, 1): 0.6302224000000003, (2, 4): 5.0, (2, 0): 2.6606031999999997, (4, 3): 5.9187748000000004, (2, 3): 2.831957599999999, (3, 4): 3.008242, (0, 2): 1.9260735999999998}
# Iterative:  5
# 0.00682902336121s
# {(1, 3): 1.644696319999999, (3, 0): 2.8185085119999993, (2, 1): 2.7586908800000005, (2, 5): 2.701635252, (4, 0): 5.065203103999999, (1, 2): 2.795942712, (3, 3): 3.6394050640000004, (4, 4): 5.462939968, (1, 5): 1.476995276, (2, 2): 5.072484447999999, (4, 1): 6.160346368000001, (1, 1): 1.3024078, (3, 2): 5.955530680000001, (0, 0): 1.3164806719999997, (4, 5): 3.0725766080000003, (0, 4): 2.6214394879999996, (1, 4): 2.6916784519999997, (0, 5): 1.3194793439999999, (4, 2): 10.0, (1, 0): 1.3365067039999996, (3, 5): 1.777961116, (0, 1): 0.9985299200000002, (2, 4): 5.0, (2, 0): 2.953069695999999, (4, 3): 5.95553068, (2, 3): 3.000752408, (3, 4): 3.1014162840000004, (0, 2): 2.3063151679999994}
# Iterative:  6
# 0.00768995285034s
# {(1, 3): 1.76455482996, (3, 0): 2.931104929919999, (2, 1): 2.8248681984800004, (2, 5): 2.7278469474400002, (4, 0): 5.122558192, (1, 2): 2.8652688074399997, (3, 3): 3.6690834682799998, (4, 4): 5.46481159552, (1, 5): 1.5047229020799997, (2, 2): 5.11342975744, (4, 1): 6.16244849152, (1, 1): 1.53413835192, (3, 2): 5.9716455020799994, (0, 0): 1.5474806899199995, (4, 5): 3.1097125459999995, (0, 4): 2.6340030566399992, (1, 4): 2.71851841172, (0, 5): 1.3637593366799996, (4, 2): 10.0, (1, 0): 1.5623164932799998, (3, 5): 1.8409879492399999, (0, 1): 1.2382385472000004, (2, 4): 5.0, (2, 0): 3.050962883839999, (4, 3): 5.9716455020799994, (2, 3): 3.06576854408, (3, 4): 3.13846201468, (0, 2): 2.437634885759999}
# Iterative:  7
# 0.0086350440979s
# {(1, 3): 1.8076954900259998, (3, 0): 2.978987277708799, (2, 1): 2.8686511226943994, (2, 5): 2.7341997595924, (4, 0): 5.1442929506176, (1, 2): 2.9074079975735994, (3, 3): 3.6818290073379996, (4, 4): 5.4650736233728, (1, 5): 1.5232211825323998, (2, 2): 5.1271348037376, (4, 1): 6.162742788812801, (1, 1): 1.5918571621992, (3, 2): 5.974851027925199, (0, 0): 1.6393205918079992, (4, 5): 3.1253494399551993, (0, 4): 2.6375208558591994, (1, 4): 2.7288494412428, (0, 5): 1.3758354684315994, (4, 2): 10.0, (1, 0): 1.6509260126671994, (3, 5): 1.8661678927616, (0, 1): 1.3331514365776, (2, 4): 5.0, (2, 0): 3.0944894104192, (4, 3): 5.974851027925199, (2, 3): 3.085471231302399, (3, 4): 3.1459994927175994, (0, 2): 2.505556678719999}
# Iterative:  8
# 0.00948810577393s
# {(1, 3): 1.822401910246491, (3, 0): 2.997862271225088, (2, 1): 2.8834310700356074, (2, 5): 2.73725723527058, (4, 0): 5.153429530545152, (1, 2): 2.922605995275983, (3, 3): 3.684376112083108, (4, 4): 5.465110307272192, (1, 5): 1.5287968090360078, (2, 2): 5.133228517458687, (4, 1): 6.162783990433791, (1, 1): 1.6255280094257194, (3, 2): 5.975967602468423, (0, 0): 1.6799683702499837, (4, 5): 3.129774319665247, (0, 4): 2.638505839640575, (1, 4): 2.733164167079088, (0, 5): 1.3799456448486314, (4, 2): 10.0, (1, 0): 1.689341418071407, (3, 5): 1.8719281598901876, (0, 1): 1.3781158737733759, (2, 4): 5.0, (2, 0): 3.1116304292413433, (4, 3): 5.975967602468423, (2, 3): 3.093836555248735, (3, 4): 3.1488010120957397, (0, 2): 2.5336794354437115}
# Iterative:  9
# 0.0104420185089s
# {(1, 3): 1.8284523823041463, (3, 0): 3.0056212550767967, (2, 1): 2.890235105339158, (2, 5): 2.738050747824834, (4, 0): 5.157108394370109, (1, 2): 2.929057174957807, (3, 3): 3.6852756604018087, (4, 4): 5.465115443018106, (1, 5): 1.5312013200795813, (2, 2): 5.135628260093787, (4, 1): 6.162789758660731, (1, 1): 1.637557718154257, (3, 2): 5.976224060018607, (0, 0): 1.6967954730784816, (4, 5): 3.1312908107277533, (0, 4): 2.6387816350993605, (1, 4): 2.7345839103497744, (0, 5): 1.3811752419706467, (4, 2): 10.0, (1, 0): 1.7047747917831717, (3, 5): 1.8740207756191218, (0, 1): 1.3969134940715005, (2, 4): 5.0, (2, 0): 3.1187206553669675, (4, 3): 5.976224060018607, (2, 3): 3.096802755779604, (3, 4): 3.1494030711105583, (0, 2): 2.5458666701297656}
# Iterative:  10
# 0.0113079547882s
# {(1, 3): 1.830664419208109, (3, 0): 3.008767676558013, (2, 1): 2.8928973232970603, (2, 5): 2.7383655466989087, (4, 0): 5.15861606696319, (1, 2): 2.931524323506427, (3, 3): 3.685479372789462, (4, 4): 5.465116162022534, (1, 5): 1.531913384911962, (2, 2): 5.136620891751375, (4, 1): 6.162790566212503, (1, 1): 1.6428998966617967, (3, 2): 5.976304980429429, (0, 0): 1.7038353753032807, (4, 5): 3.1317219234051765, (0, 4): 2.6388588578278207, (1, 4): 2.7351757591668604, (0, 5): 1.3815840749991577, (4, 2): 10.0, (1, 0): 1.7110974024759917, (3, 5): 1.8745196289205934, (0, 1): 1.4050345225824665, (2, 4): 5.0, (2, 0): 3.1215943737999514, (4, 3): 5.976304980429429, (2, 3): 3.0979741246507735, (3, 4): 3.1496153986116044, (0, 2): 2.550936569288545}
# Iterative:  11
# 0.0123240947723s
# {(1, 3): 1.831534515591563, (3, 0): 3.0100524722175073, (2, 1): 2.89401350477789, (2, 5): 2.7384503109682794, (4, 0): 5.15922946170684, (1, 2): 2.932526334410359, (3, 3): 3.6855452155733524, (4, 4): 5.465116262683154, (1, 5): 1.532180946236906, (2, 2): 5.137023212331993, (4, 1): 6.16279067926975, (1, 1): 1.645006021865123, (3, 2): 5.976324904725321, (0, 0): 1.7067377092388352, (4, 5): 3.1318603375949317, (0, 4): 2.63888048019179, (1, 4): 2.7353804462884055, (0, 5): 1.381705782577358, (4, 2): 10.0, (1, 0): 1.713649465791904, (3, 5): 1.8746907461297841, (0, 1): 1.4084265421078557, (2, 4): 5.0, (2, 0): 3.122768885301725, (4, 3): 5.976324904725321, (2, 3): 3.0984248935797956, (3, 4): 3.1496649808523234, (0, 2): 2.5530488467784327}
# Iterative:  12
# 0.013188123703s
# {(1, 3): 1.8318714150535989, (3, 0): 3.010575844666281, (2, 1): 2.8944643657709275, (2, 5): 2.7384810184656683, (4, 0): 5.159479768581199, (1, 2): 2.9329206476758776, (3, 3): 3.685561238636615, (4, 4): 5.465116276775641, (1, 5): 1.532261471619008, (2, 2): 5.137187643942242, (4, 1): 6.1627906950977644, (1, 1): 1.6458798686897764, (3, 2): 5.976330908420907, (0, 0): 1.7079330496691418, (4, 5): 3.1318999507834837, (0, 4): 2.6388865344537007, (1, 4): 2.735460082327993, (0, 5): 1.3817451399244005, (4, 2): 10.0, (1, 0): 1.7146866503596696, (3, 5): 1.8747341346767257, (0, 1): 1.4098451037969135, (2, 4): 5.0, (2, 0): 3.123247267585593, (4, 3): 5.976330908420907, (2, 3): 3.098601394189098, (3, 4): 3.149681624421786, (0, 2): 2.553919867021854}
# Iterative:  13
# 0.0140509605408s
# {(1, 3): 1.832003431846166, (3, 0): 3.0107892886587506, (2, 1): 2.8946491770199043, (2, 5): 2.738489692440701, (4, 0): 5.1595817850633505, (1, 2): 2.9330795241130536, (3, 3): 3.6855661860146958, (4, 4): 5.465116278748589, (1, 5): 1.5322898791170643, (2, 2): 5.137254617461982, (4, 1): 6.162790697313686, (1, 1): 1.6462325556942077, (3, 2): 5.976332450294026, (0, 0): 1.7084232607226884, (4, 5): 3.131912317231662, (0, 4): 2.638888229647036, (1, 4): 2.7354893020670823, (0, 5): 1.381756922102111, (4, 2): 10.0, (1, 0): 1.7151068764848147, (3, 5): 1.8747483775236404, (0, 1): 1.4104316626869253, (2, 4): 5.0, (2, 0): 3.1234423904180004, (4, 3): 5.976332450294026, (2, 3): 3.0986713353299042, (3, 4): 3.1496857911262928, (0, 2): 2.5542782187924806}
# Iterative:  14
# 0.0149230957031s
# {(1, 3): 1.8320557656173555, (3, 0): 3.010876300047702, (2, 1): 2.894724307068698, (2, 5): 2.7384926779648495, (4, 0): 5.1596233845673884, (1, 2): 2.9331430941207564, (3, 3): 3.685567449064077, (4, 4): 5.465116279024802, (1, 5): 1.5322987704496829, (2, 2): 5.137281934658519, (4, 1): 6.162790697623914, (1, 1): 1.646376587172997, (3, 2): 5.976332904541612, (0, 0): 1.7086240111076838, (4, 5): 3.1319159104776215, (0, 4): 2.63888870430117, (1, 4): 2.7355005317674266, (0, 5): 1.3817606846876826, (4, 2): 10.0, (1, 0): 1.7152775973203769, (3, 5): 1.8747521837077892, (0, 1): 1.410673519900699, (2, 4): 5.0, (2, 0): 3.1235219308298046, (4, 3): 5.976332904541612, (2, 3): 3.0986990708479754, (3, 4): 3.1496871355468934, (0, 2): 2.554425146466156}
# Iterative:  15
# 0.0157759189606s
# {(1, 3): 1.832076533487039, (3, 0): 3.0109117773644156, (2, 1): 2.8947549460056896, (2, 5): 2.738493566791023, (4, 0): 5.159640344155607, (1, 2): 2.9331687579797694, (3, 3): 3.685567829349498, (4, 4): 5.465116279063471, (1, 5): 1.5323018508155133, (2, 2): 5.137293070316172, (4, 1): 6.162790697667348, (1, 1): 1.64643506035935, (3, 2): 5.976333024752398, (0, 0): 1.7087060930088556, (4, 5): 3.1319170222894224, (0, 4): 2.6388888372043273, (1, 4): 2.735504817524693, (0, 5): 1.3817618362682704, (4, 2): 10.0, (1, 0): 1.7153469428217931, (3, 5): 1.8747533970972332, (0, 1): 1.4107727945410486, (2, 4): 5.0, (2, 0): 3.1235543626866678, (4, 3): 5.976333024752398, (2, 3): 3.098710197812173, (3, 4): 3.1496874905479197, (0, 2): 2.5544852946169154}
# Iterative:  16
# 0.0167570114136s
# {(1, 3): 1.8320848610601292, (3, 0): 3.0109262415581575, (2, 1): 2.894767419822609, (2, 5): 2.7384938673538928, (4, 0): 5.159647258957918, (1, 2): 2.933179116844515, (3, 3): 3.685567929932365, (4, 4): 5.465116279068885, (1, 5): 1.532302864186787, (2, 2): 5.137297610776133, (4, 1): 6.162790697673429, (1, 1): 1.6464588688192952, (3, 2): 5.976333059787133, (0, 0): 1.7087396265960082, (4, 5): 3.1319173528672692, (0, 4): 2.638888874417211, (1, 4): 2.7355064869011785, (0, 5): 1.381762206930288, (4, 2): 10.0, (1, 0): 1.7153751446052734, (3, 5): 1.8747537359424664, (0, 1): 1.410813459793883, (2, 4): 5.0, (2, 0): 3.123567585165752, (4, 3): 5.976333059787133, (2, 3): 3.0987146621875463, (3, 4): 3.149687602126815, (0, 2): 2.5545098838004}
# Iterative:  17
# 0.0176150798798s
# {(1, 3): 1.8320882030872243, (3, 0): 3.0109321388345758, (2, 1): 2.8947725022395683, (2, 5): 2.7384939620090476, (4, 0): 5.159650078177314, (1, 2): 2.9331833135214986, (3, 3): 3.6855679598147706, (4, 4): 5.465116279069644, (1, 5): 1.5323032202943374, (2, 2): 5.137299461923205, (4, 1): 6.1627906976742794, (1, 1): 1.6464685534021462, (3, 2): 5.976333069280365, (0, 0): 1.7087533172251128, (4, 5): 3.131917455941558, (0, 4): 2.6388888848368186, (1, 4): 2.735507140767284, (0, 5): 1.3817623246518334, (4, 2): 10.0, (1, 0): 1.7153866180573965, (3, 5): 1.8747538426064978, (0, 1): 1.4108300850677828, (2, 4): 5.0, (2, 0): 3.1235729761941893, (4, 3): 5.976333069280365, (2, 3): 3.098716465315306, (3, 4): 3.1496876328898136, (0, 2): 2.5545199279814725}
# Iterative:  18
# 0.0185430049896s
# {(1, 3): 1.8320895523767862, (3, 0): 3.010934543216136, (2, 1): 2.894774572571915, (2, 5): 2.7384939944030586, (4, 0): 5.1596512276120094, (1, 2): 2.9331850153332084, (3, 3): 3.685567967948916, (4, 4): 5.46511627906975, (1, 5): 1.53230334399938, (2, 2): 5.137300216667186, (4, 1): 6.1627906976743985, (1, 1): 1.6464724964646806, (3, 2): 5.976333072036659, (0, 0): 1.7087589043304814, (4, 5): 3.1319174876108375, (0, 4): 2.638888887754309, (1, 4): 2.7355073996367096, (0, 5): 1.38176236365485, (4, 2): 10.0, (1, 0): 1.715391288731567, (3, 5): 1.8747538736748377, (0, 1): 1.4108368747595978, (2, 4): 5.0, (2, 0): 3.123575174170907, (4, 3): 5.976333072036659, (2, 3): 3.0987171940925586, (3, 4): 3.1496876424484896, (0, 2): 2.554524028336668}
# Iterative:  19
# 0.0194821357727s
# {(1, 3): 1.8320900977397272, (3, 0): 3.010935523512984, (2, 1): 2.8947754161661865, (2, 5): 2.7384940052371953, (4, 0): 5.1596516962496075, (1, 2): 2.933185706626955, (3, 3): 3.685567970354489, (4, 4): 5.465116279069765, (1, 5): 1.5323033889202393, (2, 2): 5.137300524383927, (4, 1): 6.162790697674416, (1, 1): 1.6464741019248068, (3, 2): 5.976333072798989, (0, 0): 1.7087611837251815, (4, 5): 3.131917497737342, (0, 4): 2.638888888571206, (1, 4): 2.7355075027463314, (0, 5): 1.381762376678209, (4, 2): 10.0, (1, 0): 1.7153931907198454, (3, 5): 1.874753883512127, (0, 1): 1.4108396454128918, (2, 4): 5.0, (2, 0): 3.1235760703143765, (4, 3): 5.976333072798989, (2, 3): 3.0987174896318925, (3, 4): 3.1496876451927225, (0, 2): 2.5545257015736187}
# Iterative:  20
# 0.0203549861908s
# {(1, 3): 1.8320903188499897, (3, 0): 3.0109359231915986, (2, 1): 2.894775759921369, (2, 5): 2.738494009070265, (4, 0): 5.159651887318957, (1, 2): 2.93318598766084, (3, 3): 3.6855679710268534, (4, 4): 5.465116279069767, (1, 5): 1.5323034053494893, (2, 2): 5.137300649844012, (4, 1): 6.162790697674419, (1, 1): 1.6464747558673403, (3, 2): 5.976333073020744, (0, 0): 1.7087621134738697, (4, 5): 3.131917500992011, (0, 4): 2.6388888887999378, (1, 4): 2.735507544066197, (0, 5): 1.381762381191767, (4, 2): 10.0, (1, 0): 1.7153939655040051, (3, 5): 1.8747538865161417, (0, 1): 1.4108407755054078, (2, 4): 5.0, (2, 0): 3.123576435682597, (4, 3): 5.976333073020744, (2, 3): 3.098717609572048, (3, 4): 3.1496876460497316, (0, 2): 2.554526384183081}
# Iterative:  21
# 0.0212209224701s
# {(1, 3): 1.8320904085812393, (3, 0): 3.01093608614544, (2, 1): 2.894775900017857, (2, 5): 2.738494010430594, (4, 0): 5.159651965220217, (1, 2): 2.93318610200854, (3, 3): 3.68556797122655, (4, 4): 5.465116279069767, (1, 5): 1.5323034115384464, (2, 2): 5.137300700995563, (4, 1): 6.162790697674419, (1, 1): 1.6464750222775058, (3, 2): 5.976333073083332, (0, 0): 1.7087624926586638, (4, 5): 3.131917502077431, (0, 4): 2.638888888863982, (1, 4): 2.7355075606939634, (0, 5): 1.3817623827858532, (4, 2): 10.0, (1, 0): 1.7153942811835494, (3, 5): 1.874753887492209, (0, 1): 1.4108412363084892, (2, 4): 5.0, (2, 0): 3.123576584647687, (4, 3): 5.976333073083332, (2, 3): 3.0987176583275406, (3, 4): 3.149687646307079, (0, 2): 2.5545266626064578}
# Iterative:  22
# 0.0220749378204s
# {(1, 3): 1.832090445052598, (3, 0): 3.0109361525836826, (2, 1): 2.8947759571181906, (2, 5): 2.7384940109321456, (4, 0): 5.1596519969815064, (1, 2): 2.9331861485578505, (3, 3): 3.685567971283994, (4, 4): 5.465116279069767, (1, 5): 1.5323034138974008, (2, 2): 5.137300721850675, (4, 1): 6.162790697674419, (1, 1): 1.646475130833446, (3, 2): 5.976333073101692, (0, 0): 1.7087626472891455, (4, 5): 3.1319175024461225, (0, 4): 2.6388888888819144, (1, 4): 2.7355075674083777, (0, 5): 1.381762383366531, (4, 2): 10.0, (1, 0): 1.7153944098279772, (3, 5): 1.874753887807526, (0, 1): 1.4108414241738767, (2, 4): 5.0, (2, 0): 3.1235766453825455, (4, 3): 5.976333073101692, (2, 3): 3.098717678157782, (3, 4): 3.149687646389382, (0, 2): 2.554526776155253}
# End iteration, start best policy0.0225489139557s
# End best policy0.0232739448547s
# All pass
#
# Process finished with exit code 0
